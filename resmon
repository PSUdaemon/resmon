#!/usr/bin/perl

use lib '/opt/resmon/lib';

use strict;
use Time::HiRes qw( gettimeofday tv_interval sleep );
use Data::Dumper;
use POSIX qw( setsid );
use Getopt::Long;
use vars qw($config_file $debug $status_file $config);

use Resmon::Config;
use Resmon::ExtComm;
use Resmon::Status;
use Resmon::Module;

GetOptions(
  "c=s" => \$config_file,
  "d"   => \$debug,
  "f=s" => \$status_file,
);

$config_file ||= 'resmon.conf';
die "Cannot open configuration file: $config_file" unless (-r $config_file);

sub configure {
  $config = Resmon::Config->new($config_file);
  $config->{statusfile} = $status_file if($status_file);
  print Dumper($config) if($debug);
}
unless($debug) {
  fork && exit;
  setsid;
}
configure();
$SIG{'HUP'} = \&configure;

use Time::HiRes qw( gettimeofday tv_interval sleep );

my $rmlast = undef;
sub wait_interval {
  $rmlast = [gettimeofday] unless defined($rmlast);
  my $elapsed = $config->{interval} - tv_interval($rmlast);
  if($elapsed > 0) {
    sleep($elapsed);
  }
  $rmlast = [gettimeofday];
}

my $list = [];
my $status = Resmon::Status->new($config->{statusfile});
while(1) {
  while(my($module_name, $mod_configs) = each %{$config->{Module}}) {
    my $coderef = Resmon::Module::fetch_monitor($module_name);
    foreach my $monobj (@$mod_configs) {
      my $check_rv = 'BAD',
      my $check_mess = 'no data';
      if($coderef) {
        eval { ($check_rv, $check_mess) = $coderef->($monobj); };
      } else {
        eval { ($check_rv, $check_mess) = $monobj->handler(); };
      }
      if($@) {
        $status->store($module_name,$monobj->{'object'},'BAD',$@);
      } else {
        $status->store($module_name,$monobj->{'object'},$check_rv,$check_mess);
      }
    }
  }
  $status->close();
  wait_interval();
  print "\n---- ".localtime(time)."----------\n"
    unless $status->open();
}

